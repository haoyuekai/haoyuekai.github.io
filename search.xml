<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于ES6箭头函数]]></title>
    <url>%2F2018%2F06%2F07%2F%E5%85%B3%E4%BA%8EES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[ES6发布到现在马上就要三年了，作为一个比较守旧的前端，一直也没有个系统的了解（主要是在小公司上班，工作中用不到啊，懒癌晚期的我，又没有足够的动力去系统的学习）。 最近公司项目（外包做的）bug频繁出现，有了用Vue重构的想法。至于为什么不用React，大概是觉得相比较而言，Vue更简单一些吧。在使用Vue脚手架的时候，接触到箭头函数，也是时候应该了解一下了。 好了，废话不多说了，下面说一下关于箭头函数的学习。 基本语法首先，先看一下箭头函数的基本语法： 1let func = value =&gt; value; 相当于： 123let func = function (value) &#123; return value; &#125;; 如果需要给函数传入多个参数： 1let func = (value, num) =&gt; value * num; 如果函数的代码块需要多条语句： 123let func = (value, num) =&gt; &#123; return value * num&#125;; 如果需要直接返回一个对象： 1let func = (value, num) =&gt; (&#123;total: value * num&#125;); 与变量解构结合： 12345678let func = (&#123;value, num&#125;) =&gt; (&#123;total: value * num&#125;)// 使用var result = func(&#123; value: 10, num: 10&#125;)console.log(result); // &#123;total: 100&#125; 比较没有this箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。 这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this。 模拟一个实际开发中的例子： 我们的需求是点击一个按钮，改变该按钮的背景色。 为了方便开发，我们抽离一个 Button 组件，当需要使用的时候，直接： 12// 传入元素 id 值即可绑定该元素点击时改变背景色的事件new Button(&quot;button&quot;) HTML 代码如下： 1&lt;button id=&quot;button&quot;&gt;点击变色&lt;/button&gt; JavaScript 代码如下： 1234567891011121314function Button(id) &#123; this.element = document.querySelector(&quot;#&quot; + id); this.bindEvent();&#125;Button.prototype.bindEvent = function() &#123; this.element.addEventListener(&quot;click&quot;, this.setBgColor, false);&#125;;Button.prototype.setBgColor = function() &#123; this.element.style.backgroundColor = &apos;#1abc9c&apos;&#125;;var button = new Button(&quot;button&quot;); 看着好像没有问题，结果却是报错 Uncaught TypeError: Cannot read property ‘style’ of undefined 这是因为当使用 addEventListener() 为一个元素注册事件的时候，事件函数里的 this 值是该元素的引用。 所以如果我们在 setBgColor 中 console.log(this)，this 指向的是按钮元素，那 this.element 就是 undefined，报错自然就理所当然了。 也许你会问，既然 this 都指向了按钮元素，那我们直接修改 setBgColor 函数为： 123Button.prototype.setBgColor = function() &#123; this.style.backgroundColor = &apos;#1abc9c&apos;&#125;; 不就可以解决这个问题了？ 确实可以这样做，但是在实际的开发中，我们可能会在 setBgColor 中还调用其他的函数，比如写成这种： 1234Button.prototype.setBgColor = function() &#123; this.setElementColor(); this.setOtherElementColor();&#125;; 所以我们还是希望 setBgColor 中的 this 是指向实例对象的，这样就可以调用其他的函数。 利用 ES5，我们一般会这样做： 123Button.prototype.bindEvent = function() &#123; this.element.addEventListener(&quot;click&quot;, this.setBgColor.bind(this), false);&#125;; 为避免 addEventListener 的影响，使用 bind 强制绑定 setBgColor() 的 this 为实例对象 使用 ES6，我们可以更好的解决这个问题： 123Button.prototype.bindEvent = function() &#123; this.element.addEventListener(&quot;click&quot;, event =&gt; this.setBgColor(event), false);&#125;; 由于箭头函数没有 this，所以会向外层查找 this 的值，即 bindEvent 中的 this，此时 this 指向实例对象，所以可以正确的调用 this.setBgColor 方法， 而 this.setBgColor 中的 this 也会正确指向实例对象。 在这里再额外提一点，就是注意 bindEvent 和 setBgColor 在这里使用的是普通函数的形式，而非箭头函数，如果我们改成箭头函数，会导致函数里的 this 指向 window 对象 (非严格模式下)。 最后，因为箭头函数没有 this，所以也不能用 call()、apply()、bind() 这些方法改变 this 的指向，可以看一个例子： 123var value = 1;var result = (() =&gt; this.value).bind(&#123;value: 2&#125;)();console.log(result); // 1 没有 arguments箭头函数没有自己的 arguments对象，这不一定是件坏事，因为箭头函数可以访问外围函数的 arguments 对象： 123456function constant() &#123; return () =&gt; arguments[0]&#125;var result = constant(1);console.log(result()); // 1 那如果我们就是要访问箭头函数的参数呢？ 你可以通过命名参数或者 rest 参数的形式访问参数: 1let nums = (...nums) =&gt; nums; 不能通过 new 关键字调用JavaScript 函数有两个内部方法：[[Call]] 和 [[Construct]]。 当通过 new 调用函数时，执行 [[Construct]] 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。 当直接调用的时候，执行 [[Call]] 方法，直接执行函数体。 箭头函数并没有 [[Construct]] 方法，不能被用作构造函数，如果通过 new 的方式调用，会报错。 12var Foo = () =&gt; &#123;&#125;;var foo = new Foo(); // TypeError: Foo is not a constructor 没有 new.target因为不能使用 new 调用，所以也没有 new.target 值。 关于 new.target，可以参考es6.ruanyifeng.com/#docs/class… 没有原型由于不能使用 new 调用箭头函数，所以也没有构建原型的需求，于是箭头函数也不存在 prototype 这个属性。 12var Foo = () =&gt; &#123;&#125;;console.log(Foo.prototype); // undefined 没有 super连原型都没有，自然也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的，不过跟 this、arguments、new.target 一样，这些值由外围最近一层非箭头函数决定。 总结最后，关于箭头函数，引用 MDN 的介绍就是： An arrow function expression has a shorter syntax than a function expression and does not have its own this, arguments, super, or new.target. These function expressions are best suited for non-method functions, and they cannot be used as constructors. 翻译过来就是： 箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数(non-method functions)，并且它们不能用作构造函数。 那么什么是 non-method functions 呢？ 我们先来看看 method 的定义： A method is a function which is a property of an object. 对象属性中的函数就被称之为 method，那么 non-mehtod 就是指不被用作对象属性中的函数了，可是为什么说箭头函数更适合 non-method 呢？ 让我们来看一个例子就明白了： 1234567891011var obj = &#123; i: 10, b: () =&gt; console.log(this.i, this), c: function() &#123; console.log( this.i, this) &#125;&#125;obj.b();// undefined Windowobj.c();// 10, Object &#123;...&#125; 自执行函数自执行函数的形式为： 123(function()&#123; console.log(1)&#125;)() 或者 123(function()&#123; console.log(1)&#125;()) 利用箭头简化自执行函数的写法： 123(() =&gt; &#123; console.log(1)&#125;)() 但是注意：使用以下这种写法却会报错： 123(() =&gt; &#123; console.log(1)&#125;()) ES6系列感谢冴羽的文章，作为ES6初学者，站在巨人的肩膀上学习，相对来说，还是简单不少的。更多ES6内容…]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
