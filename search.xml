<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[svg]]></title>
    <url>%2F2018%2F12%2F13%2Fsvg%2F</url>
    <content type="text"><![CDATA[原生svg基础形状 矩形 rect 圆形 circle 椭圆 ellipse 线 line 折线 polyline 多边形 polygon 路径 path M = moveto L = lineto H = horizontal lineto V = vertical lineto C = curveto ‘C x1 y1 x2 y2 x y’ 三次贝塞尔曲线 S = smooth curveto ‘S x2 y2 x y’ 简化的贝塞尔曲线 Q = quadratic Belzier curve ‘Q x1 y1 x y’ 二次贝塞尔曲线Q T = smooth quadratic Belzier curveto Q命令的简写命令 A = elliptical Arc ‘A rx,ry x-axis-rotation large-arc-flag sweep-flag x,y’ Z = closepath 注释：以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位。 基础属性 viewBox 视窗(x,y,width,height)视窗,viewBox和preserveAspectRatio 描边（stroke stroke-width stroke-opacity stroke-linejoin stroke-linecap stroke-miterlimit stroke-dasharray stroke-dashoffset ） stroke, stroke-width, stroke-opacity stroke-linecap 线条两端样式： 对接(butt)、方形(square)和圆形(round) stroke-linejoin 线条拐角样式： 尖角(miter)、圆角(round)和斜角(bevel) stroke-miterlimit stroke-miterlimit 属性给 miter-length 和 stroke-width 之间的比率做了限制，它的比值范围应大于或等于1。当比值不在这个范围的时候， stroke 就会被转换成斜角（bevel）。著作权归作者所有。 stroke-dasharray(虚线) stroke-dashoffset(x线条起始点) stroke-dasharray 参数： 第一个值是划线的长度，第二个值是各个划线之间的空格大小 （可接受多组参数，循环） 填充（fill fill-rule fill-opacity） fill-rull (nonzero evenodd inherit) nonzero—这个规则通过从canvas上的某个点往任一方向绘制射线到无穷远，然后检查图形的线段和射线相交的点，来确定“内部区域”。从0开始计数，每次路径线段是从左到右穿过射线就加一，从右到左的就减一。通过计算交叉点，如果结果是0，则这个点在路径外边，不然，就是在里边。 evenodd—这个规则通过从canvas上某个点往任一方向绘制射线到无穷远，然后计算给定图形上线段路径和该射线交叉点的数量。如果这个数是奇数，那么该点在图形内部；如果是偶数，该点在图形外部。 常用svg标签12345678910111213141516171819202122&lt;g&gt;&lt;/g&gt; //对svg元素进行分组，添加公共的属性 &lt;defs&gt;&lt;/defs&gt; // 预定义svg图像，用于重复使用，被此标签包裹的svg元素，不会绘制到画布上，一般和&lt;use/&gt;搭配使用，&lt;use&gt;引用的id是&lt;defs&gt;包含的元素&lt;symbol&gt;&lt;/symbol&gt;和&lt;def&gt;类似，此元素可以有preserveAspectRatio和viewBox属性。而&lt;g&gt;元素不能拥有这些属性。因此相比于在&lt;defs&gt;元素中使用&lt;g&gt;的方式来复用图形，使用&lt;symbol&gt;元素也许是一个更好的选择，&lt;use&gt;引用&lt;symbol&gt;&lt;use&gt; 引用svg代码，属性（xlink:href=`$&#123;id&#125;` x y）&lt;text&gt;&lt;/text&gt; // 属性和html,css类似, 注意：x,y 是文字左下角的坐标&lt;image xlink:href="url"&gt;&lt;/image&gt;&lt;filter&gt; // 滤镜，定义在&lt;defs&gt;中,被其他元素引用&lt;tag filter:url(id)/&gt;&lt;svg&gt; &lt;defs&gt; &lt;filter id="Gaussian_Blur"&gt; &lt;feGaussianBlur in="SourceGraphic" stdDeviation="3" /&gt; &lt;/filter&gt; &lt;/defs&gt; &lt;rect x=20 y=20 width=100 height=50 style="fill:#ff0000;stroke:#000000;stroke-width:2;filter:url(#Gaussian_Blur)"&gt;&lt;/rect&gt;&lt;/svg&gt;... svg方法 path.getPointAtLength(number) path.getTotalLength() element.remove() SVGLoad（onload）：当客户端完全解析了SVG文档或者其中的元素，或者所需的外部资源已经准好的时候会触发此事件，此时已经准备开始渲染SVG图像。 SVGUnload（onunload）：当SVG文档从浏览器窗口或者某个框架中被删除后会触发此事件 SVGAbort（onabort）：当正在载入的文档或者元素被中止时会触发此事件。 SVGError（onerror）：当载入一个元素或者当执行脚本发生错误时，都会触发此事件。 SVGResize（onresize）：当嵌入有SVG文档的浏览器窗口或者框架的尺寸发生改变时会触发此事件 SVGScroll（onscroll）：当用户拖动窗口的滚动条或者浏览文档视图时，或当通过脚本改变了“currentTranslate”属性值时 SVGZoom（onzoom ）：当用户缩放SVG文档视图时，或当通过脚本改变了“currentScale”属性值时 svg交互 标签交互1234&lt;!-- 写在目标标签内 --&gt;&lt;set attributeName="fill" from="lightgrey" to="red" begin="mouseover" end="mouseout" /&gt;&lt;!-- 通过id控制其他目标元素 --&gt;&lt;set attributeName="fill" from="black" to="red" begin="changeToRed.mouseover" end="changeToRed.mouseout"/&gt; 123&lt;!-- 支持鼠标事件和键盘事件(?????) --&gt;&lt;animate attributeName="fill" from="blue" to="green" begin="mouseover" dur="2s" fill="restore" /&gt;&lt;animateMotion dur="2s" path='' repeatCount=2 /&gt; js 原文链接： 大漠 Snap.svg官网]]></content>
      <tags>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记-数据结构]]></title>
    <url>%2F2018%2F07%2F13%2FJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Java工具包提供了强大的数据结构。在Java中的数据结构主要包括以下几种接口和类： 枚举（Enumeration） 位集合（BitSet） 向量（Vector） 栈（Stack） 字典（Dictionary） 哈希表（Hashtable） 属性（Properties） 枚举（Enumeration）Enumeration接口中定义了一些方法，通过这些方法可以枚举（一次获得一个）对象集合中的元素。123456789101112131415161718192021import java.util.Vector;import java.util.Enumeration; public class EnumerationTester &#123; public static void main(String args[]) &#123; Enumeration&lt;String&gt; days; Vector&lt;String&gt; dayNames = new Vector&lt;String&gt;(); dayNames.add("Sunday"); dayNames.add("Monday"); dayNames.add("Tuesday"); dayNames.add("Wednesday"); dayNames.add("Thursday"); dayNames.add("Friday"); dayNames.add("Saturday"); days = dayNames.elements(); while (days.hasMoreElements())&#123; //循环输出 System.out.println(days.nextElement()); &#125; &#125;&#125; 运行结果如下： Sunday Monday Tuesday Wednesday Thursday Friday Saturday 位集合（BitSet）一个Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。BitSet定义了两个构造方法： 构造方法创建一个默认的对象：BitSet()； 允许用户指定初始大小。所有位初始化为0：BitSet(int size)。 BitSet中实现了Cloneable接口中定义的方法如下： void and(BitSet set) =&gt;对此目标位 set 和参数位 set 执行逻辑与操作； void andNot(BitSet set) =&gt;清除此 BitSet 中所有的位，其相应的位在指定的 BitSet 中已设置； int cardinality( ) =&gt;返回此 BitSet 中设置为 true 的位数； void clear( ) =&gt;将此 BitSet 中的所有位设置为 false； void clear(int index) =&gt;将索引指定处的位设置为 false； void clear(int startIndex, int endIndex) =&gt;将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的位设置为 false； Object clone( ) =&gt;复制此 BitSet，生成一个与之相等的新 BitSet； boolean equals(Object bitSet) =&gt;将此对象与指定的对象进行比较； void flip(int index) =&gt;将指定索引处的位设置为其当前值的补码； void flip(int startIndex, int endIndex) =&gt;将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的每个位设置为其当前值的补码； boolean get(int index) =&gt;返回指定索引处的位值； BitSet get(int startIndex, int endIndex) =&gt;返回一个新的 BitSet，它由此 BitSet 中从 fromIndex（包括）到 toIndex（不包括）范围内的位组成； int hashCode( ) =&gt;返回此位 set 的哈希码值； boolean intersects(BitSet bitSet) =&gt;如果指定的 BitSet 中有设置为 true 的位，并且在此 BitSet 中也将其设置为 true，则返回 true； boolean isEmpty( ) =&gt;如果此 BitSet 中没有包含任何设置为 true 的位，则返回 true； int length( ) =&gt;返回此 BitSet 的”逻辑大小”：BitSet 中最高设置位的索引加 1； int nextClearBit(int startIndex) =&gt;返回第一个设置为 false 的位的索引，这发生在指定的起始索引或之后的索引上； int nextSetBit(int startIndex) =&gt;返回第一个设置为 true 的位的索引，这发生在指定的起始索引或之后的索引上； void or(BitSet bitSet) =&gt;对此位 set 和位 set 参数执行逻辑或操作； void set(int index) =&gt;将指定索引处的位设置为 true； void set(int index, boolean v) =&gt;将指定索引处的位设置为指定的值； void set(int startIndex, int endIndex) =&gt;将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的位设置为 true； void set(int startIndex, int endIndex, boolean v) =&gt;将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的位设置为指定的值； int size( ) =&gt;返回此 BitSet 表示位值时实际使用空间的位数； String toString( ) =&gt;返回此位 set 的字符串表示形式； void xor(BitSet bitSet) =&gt;对此位 set 和位 set 参数执行逻辑异或操作。 实例：12345678910111213141516171819202122232425262728293031import java.util.BitSet; public class BitSetDemo &#123; public static void main(String args[]) &#123; BitSet bits1 = new BitSet(16); BitSet bits2 = new BitSet(16); // set some bits for(int i=0; i&lt;16; i++) &#123; if((i%2) == 0) bits1.set(i); if((i%5) != 0) bits2.set(i); &#125; System.out.println(bits1); //&#123;0, 2, 4, 6, 8, 10, 12, 14&#125; System.out.println(bits2); //&#123;1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14&#125; // AND bits bits2.and(bits1); System.out.println(bits2); //&#123;2, 4, 6, 8, 12, 14&#125; // OR bits bits2.or(bits1); System.out.println(bits2); //&#123;0, 2, 4, 6, 8, 10, 12, 14&#125; // XOR bits bits2.xor(bits1); System.out.println(bits2);//&#123;&#125; &#125;&#125; 向量（Vector）Vector类实现了一个动态数组。和ArrayList和相似，但是Vector是同步访问的。主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。 向量的构造方法有四种： 创建一个默认的向量，默认大小为10：Vector()； 创建指定大小的向量：Vector(int size)； 创建指定大小的向量，并且增量用incr指定. 增量表示向量每次增加的元素数目：Vector(int size,int incr)； 创建一个包含集合c元素的向量：Vector(Collection c)。 向量的方法： void add(int index, Object element) =&gt;在此向量的指定位置插入指定的元素； boolean add(Object o) =&gt;将指定元素添加到此向量的末尾； boolean addAll(Collection c) =&gt;将指定 Collection 中的所有元素添加到此向量的末尾，按照指定 collection 的迭代器所返回的顺序添加这些元素； boolean addAll(int index, Collection c) =&gt;在指定位置将指定 Collection 中的所有元素插入到此向量中； void addElement(Object obj) =&gt;将指定的组件添加到此向量的末尾，将其大小增加 1； int capacity() =&gt;返回此向量的当前容量； void clear() =&gt;从此向量中移除所有元素； Object clone() =&gt;返回向量的一个副本； boolean contains(Object elem) =&gt;如果此向量包含指定的元素，则返回 true； boolean containsAll(Collection c) =&gt;如果此向量包含指定 Collection 中的所有元素，则返回 true； void copyInto(Object[] anArray) =&gt;将此向量的组件复制到指定的数组中； Object elementAt(int index) =&gt;返回指定索引处的组件； Enumeration elements() =&gt;返回此向量的组件的枚举； void ensureCapacity(int minCapacity) =&gt;增加此向量的容量（如有必要），以确保其至少能够保存最小容量参数指定的组件数； boolean equals(Object o) =&gt;比较指定对象与此向量的相等性； Object firstElement() =&gt;返回此向量的第一个组件（位于索引 0) 处的项）； Object get(int index) =&gt;返回向量中指定位置的元素； int hashCode() =&gt;返回此向量的哈希码值； int indexOf(Object elem) =&gt;返回此向量中第一次出现的指定元素的索引，如果此向量不包含该元素，则返回 -1； int indexOf(Object elem, int index) =&gt;返回此向量中第一次出现的指定元素的索引，从 index 处正向搜索，如果未找到该元素，则返回 -1； void insertElementAt(Object obj, int index) =&gt;将指定对象作为此向量中的组件插入到指定的 index 处； boolean isEmpty() =&gt;测试此向量是否不包含组件； Object lastElement() =&gt;返回此向量的最后一个组件； int lastIndexOf(Object elem) =&gt;返回此向量中最后一次出现的指定元素的索引；如果此向量不包含该元素，则返回 -1； int lastIndexOf(Object elem, int index) =&gt;返回此向量中最后一次出现的指定元素的索引，从 index 处逆向搜索，如果未找到该元素，则返回 -1； Object remove(int index) =&gt;移除此向量中指定位置的元素； boolean remove(Object o) =&gt;移除此向量中指定元素的第一个匹配项，如果向量不包含该元素，则元素保持不变； boolean removeAll(Collection c) =&gt;从此向量中移除包含在指定 Collection 中的所有元素； void removeAllElements() =&gt;从此向量中移除全部组件，并将其大小设置为零； boolean removeElement(Object obj) =&gt;从此向量中移除变量的第一个（索引最小的）匹配项； void removeElementAt(int index) =&gt;删除指定索引处的组件； protected void removeRange(int fromIndex, int toIndex) =&gt;从此 List 中移除其索引位于 fromIndex（包括）与 toIndex（不包括）之间的所有元素； boolean retainAll(Collection c) =&gt;在此向量中仅保留包含在指定 Collection 中的元素； Object set(int index, Object element) =&gt;用指定的元素替换此向量中指定位置处的元素； void setElementAt(Object obj, int index) =&gt;将此向量指定 index 处的组件设置为指定的对象； void setSize(int newSize) =&gt;设置此向量的大小； int size() =&gt;返回此向量中的组件数； List subList(int fromIndex, int toIndex) =&gt;返回此 List 的部分视图，元素范围为从 fromIndex（包括）到 toIndex（不包括）； Object[] toArray() =&gt;返回一个数组，包含此向量中以恰当顺序存放的所有元素； Object[] toArray(Object[] a) =&gt;返回一个数组，包含此向量中以恰当顺序存放的所有元素；返回数组的运行时类型为指定数组的类型； String toString() =&gt;返回此向量的字符串表示形式，其中包含每个元素的 String 表示形式； void trimToSize() =&gt;对此向量的容量进行微调，使其等于向量的当前大小。 实例：12345678910111213141516171819202122232425262728293031323334353637import java.util.*;public class VectorDemo &#123; public static void main(String args[]) &#123; // initial size is 3, increment is 2 Vector v = new Vector(3, 2); System.out.println("Initial size: " + v.size());// 向量组件数 0 System.out.println("Initial capacity: " + v.capacity());// 向量容量 3 v.addElement(new Integer(1)); v.addElement(new Integer(2)); v.addElement(new Integer(3)); v.addElement(new Integer(4)); System.out.println("Capacity after four additions: " + v.capacity()); // 向量容量 3+2 v.addElement(new Double(5.45)); System.out.println("Current capacity: " + v.capacity()); // 向量容量 3+2 v.addElement(new Double(6.08)); v.addElement(new Integer(7)); System.out.println("Current capacity: " + v.capacity());// 向量容量 3+2+2 v.addElement(new Float(9.4)); v.addElement(new Integer(10)); System.out.println("Current capacity: " + v.capacity());// 向量容量 3+2+2+2 v.addElement(new Integer(11)); v.addElement(new Integer(12)); System.out.println("First element: " + (Integer)v.firstElement()); // 向量第一个元素 1 System.out.println("Last element: " + (Integer)v.lastElement()); // 向量最后一个元素 12 if(v.contains(new Integer(3))) // 此向量包含元素 （数字 3） System.out.println("Vcfector contains 3."); // enumerate the elements in the vector. Enumeration vEnum = v.elements(); System.out.println("\nElements in vector:"); while(vEnum.hasMoreElements()) // 枚举此向量，循环输出 System.out.print(vEnum.nextElement() + " "); System.out.println(); &#125;&#125; 栈（Stack）栈是Vector的一个子类，包含所有Vector的方法。栈中的元素，后进先出。 构造：Stack()。 方法： boolean empty() =&gt;测试堆栈是否为空； Object peek( ) =&gt;查看堆栈顶部的对象，但不从堆栈中移除它； Object pop( ) =&gt;移除堆栈顶部的对象，并作为此函数的值返回该对象； Object push(Object element) =&gt;把项压入堆栈顶部； int search(Object element) =&gt;返回对象在堆栈中的位置，以 1 为基数。 实例：123456789101112131415161718192021222324252627282930313233import java.util.*; public class StackDemo &#123; static void showpush(Stack&lt;Integer&gt; st, int a) &#123; st.push(new Integer(a)); System.out.println("push(" + a + ")"); System.out.println("stack: " + st); &#125; static void showpop(Stack&lt;Integer&gt; st) &#123; System.out.print("pop -&gt; "); Integer a = (Integer) st.pop(); System.out.println(a); System.out.println("stack: " + st); &#125; public static void main(String args[]) &#123; Stack&lt;Integer&gt; st = new Stack&lt;Integer&gt;(); // st = []; System.out.println("stack: " + st);// stack: [] showpush(st, 42); // st = [42] showpush(st, 66); // st= [42,66] showpush(st, 99); // st = [42,66,99] showpop(st); // st.pop : 99 st = [42,66] showpop(st); // st.pop : 66 st = [42] showpop(st); // st.pop : 42 st = [] try &#123; showpop(st); &#125; catch (EmptyStackException e) &#123; System.out.println("empty stack"); &#125; &#125;&#125; 字典（Dictionary）Dictionary 类是一个抽象类，用来存储键/值对，作用和Map类相似。 方法： Enumeration elements( ) =&gt;返回此 dictionary 中值的枚举； Object get(Object key) =&gt;返回此 dictionary 中该键所映射到的值； boolean isEmpty( ) =&gt;测试此 dictionary 是否不存在从键到值的映射； Enumeration keys( ) =&gt;返回此 dictionary 中的键的枚举； Object put(Object key, Object value) =&gt;将指定 key 映射到此 dictionary 中指定 value； Object remove(Object key) =&gt;从此 dictionary 中移除 key （及其相应的 value）； int size( ) =&gt;返回此 dictionary 中条目（不同键）的数量。 实际开发中，用的比较少，常用Map接口来获取键/值的存储功能。 Map 接口Map接口中键和值一一映射. 可以通过键来获取值。 给定一个键和一个值，你可以将该值存储在一个Map对象. 之后，你可以通过键来访问对应的值。 当访问的值不存在的时候，方法就会抛出一个NoSuchElementException异常. 当对象的类型和Map里元素类型不兼容的时候，就会抛出一个 ClassCastException异常。 当在不允许使用Null对象的Map中使用Null对象，会抛出一个NullPointerException 异常。 当尝试修改一个只读的Map时，会抛出一个UnsupportedOperationException异常。 方法： void clear( ) =&gt;从此映射中移除所有映射关系（可选操作）； boolean containsKey(Object k) =&gt;如果此映射包含指定键的映射关系，则返回 true； boolean containsValue(Object v)如果此映射将一个或多个键映射到指定值，则返回 true； Set entrySet( ) =&gt;返回此映射中包含的映射关系的 Set 视图； boolean equals(Object obj) =&gt;比较指定的对象与此映射是否相等； Object get(Object k) =&gt;返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null； int hashCode( ) =&gt;返回此映射的哈希码值； boolean isEmpty( )如果此映射未包含键-值映射关系，则返回 true； Set keySet( ) =&gt;返回此映射中包含的键的 Set 视图； Object put(Object k, Object v) =&gt;将指定的值与此映射中的指定键关联（可选操作）； void putAll(Map m) =&gt;从指定映射中将所有映射关系复制到此映射中（可选操作）； Object remove(Object k) =&gt;如果存在一个键的映射关系，则将其从此映射中移除（可选操作）； int size( ) =&gt;返回此映射中的键-值映射关系数； Collection values( ) =&gt;返回此映射中包含的值的 Collection 视图。 实例：123456789101112131415import java.util.*;public class CollectionsDemo &#123; public static void main(String[] args) &#123; Map m1 = new HashMap(); m1.put("Zara", "8"); // &#123;Zara=8&#125; m1.put("Mahnaz", "31"); //&#123;Zara=8, Mahnaz=31&#125; m1.put("Ayan", "12"); // &#123;Zara=8, Mahnaz=31, Ayan=12&#125; m1.put("Daisy", "14"); // &#123;Zara=8, Mahnaz=31, Ayan=12, Daisy=14&#125; System.out.println(" Map Elements"); System.out.print("\t" + m1); &#125;&#125; 哈希表（Hashtable）Hashtable是原始的java.util的一部分， 是一个Dictionary具体的实现。 构造： 默认构造方法：Hashtable()； 创建指定大小的哈希表：Hashtable(int size)； 创建了一个指定大小的哈希表，并且通过fillRatio指定填充比例。填充比例必须介于0.0和1.0之间，它决定了哈希表在重新调整大小之前的充满程度：Hashtable(int size,float fillRatio)； 创建了一个以M中元素为初始化元素的哈希表。哈希表的容量被设置为M的两倍：Hashtable(Map m)； 方法（包含Map接口中定义的方法）： void clear( ) =&gt;将此哈希表清空，使其不包含任何键； Object clone( ) =&gt;创建此哈希表的浅表副本； boolean contains(Object value) =&gt;测试此映射表中是否存在与指定值关联的键； boolean containsKey(Object key) =&gt;测试指定对象是否为此哈希表中的键； boolean containsValue(Object value) =&gt;如果此 Hashtable 将一个或多个键映射到此值，则返回 true； Enumeration elements( ) =&gt;返回此哈希表中的值的枚举； Object get(Object key) =&gt;返回指定键所映射到的值，如果此映射不包含此键的映射，则返回 null. 更确切地讲，如果此映射包含满足 (key.equals(k)) 的从键 k 到值 v 的映射，则此方法返回 v；否则，返回 null； boolean isEmpty( ) =&gt;测试此哈希表是否没有键映射到值； Enumeration keys( ) =&gt;返回此哈希表中的键的枚举； Object put(Object key, Object value) =&gt;将指定 key 映射到此哈希表中的指定 value； void rehash( ) =&gt;增加此哈希表的容量并在内部对其进行重组，以便更有效地容纳和访问其元素； Object remove(Object key) =&gt;从哈希表中移除该键及其相应的值； int size( ) =&gt;返回此哈希表中的键的数量； String toString( ) =&gt;返回此 Hashtable 对象的字符串表示形式，其形式为 ASCII 字符 “, “ （逗号加空格）分隔开的、括在括号中的一组条目。 实例：1234567891011121314151617181920212223242526272829303132import java.util.*;public class HashTableDemo &#123; public static void main(String args[]) &#123; // Create a hash map Hashtable balance = new Hashtable(); Enumeration names; String str; double bal; balance.put("Zara", new Double(3434.34)); //&#123;Zara=3434.34&#125; balance.put("Mahnaz", new Double(123.22));//&#123;Zara=3434.34,Mahnaz=123.22&#125; balance.put("Ayan", new Double(1378.00));//&#123;Zara=3434.34,Mahnaz=123.22,Ayan=1378.00&#125; balance.put("Daisy", new Double(99.22));//&#123;Zara=3434.34,Mahnaz=123.22,Ayan=1378.00,Daisy=99.22&#125; balance.put("Qadir", new Double(-19.08));//&#123;Zara=3434.34,Mahnaz=123.22,Ayan=1378.00,Daisy=99.22,Qadir=-19.08&#125; // Show all balances in hash table. names = balance.keys(); //&#123;Zara,Mahnaz,Ayan,Daisy,Qadir&#125; 无序 while(names.hasMoreElements()) &#123; str = (String) names.nextElement(); System.out.println(str + ": " + // 键名 balance.get(str)); // 键值 &#125; System.out.println(); // Deposit 1,000 into Zara's account bal = ((Double)balance.get("Zara")).doubleValue(); // 3434.34 balance.put("Zara", new Double(bal+1000)); //4434.34 System.out.println("Zara's new balance: " + balance.get("Zara")); &#125;&#125; 属性（Properties）Properties 继承于 Hashtable.表示一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。 构造（属性列表都为空）： 无默认值：Properties()； 使用propDefault 作为默认值：Properties(Properties propDefault)。 方法（包含Hashtable中所定义的方法）： String getProperty(String key) =&gt;用指定的键在此属性列表中搜索属性； String getProperty(String key, String defaultProperty) =&gt;用指定的键在属性列表中搜索属性； void list(PrintStream streamOut) =&gt;将属性列表输出到指定的输出流； void list(PrintWriter streamOut) =&gt;将属性列表输出到指定的输出流； void load(InputStream streamIn) throws IOException =&gt;从输入流中读取属性列表（键和元素对）； Enumeration propertyNames( ) =&gt;按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）； Object setProperty(String key, String value) =&gt;调用 Hashtable 的方法 put； void store(OutputStream streamOut, String description) =&gt;以适合使用 load(InputStream)方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。 实例：123456789101112131415161718192021222324252627282930313233import java.util.*; public class PropDemo &#123; public static void main(String args[]) &#123; Properties capitals = new Properties(); Set states; String str; capitals.put("Illinois", "Springfield"); capitals.put("Missouri", "Jefferson City"); capitals.put("Washington", "Olympia"); capitals.put("California", "Sacramento"); capitals.put("Indiana", "Indianapolis"); //--&#123;Missouri=Jefferson City, Illinois=Springfield, Indiana=Indianapolis, California=Sacramento, Washington=Olympia&#125; // Show all states and capitals in hashtable. states = capitals.keySet(); // get set-view of keys //--[Missouri, Illinois, Indiana, California, Washington] Iterator itr = states.iterator();// 迭代器，用于循环 while(itr.hasNext()) &#123; str = (String) itr.next(); System.out.println("The capital of " + str + " is " + capitals.getProperty(str) + "."); &#125; // look for state not in list -- specify default str = capitals.getProperty("Florida", "Not Found"); System.out.println("The capital of Florida is " + str + "."); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象-包]]></title>
    <url>%2F2018%2F07%2F12%2Fpackage%2F</url>
    <content type="text"><![CDATA[为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。 作用 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。 语法格式package pkg1[．pkg2[．pkg3…]]; 例如：12345package net.java.util;public class Something&#123; //类主体&#125; 这个文件保存的路径是“net/java/util/Something.java”。 Java中常用的包： java.lang-打包基础的类 java.io-包含输入输出功能的函数 命名通常使用小写字母来命名，避免和类、接口名字冲突。 引用包用“import”来引用，格式：import package1[.package2...]..(classname|*); 例子：123456789import payroll.Employee; public class Boss&#123; public void payEmployee(Employee e) &#123; e.mailCheck(); &#125;&#125; 注意： 类文件中可以包含任意数量的 import 声明。import 声明必须在包声明之后，类声明之前。 通常，一个公司使用它互联网域名的颠倒形式来作为它的包名.例如：互联网域名是 haichufang.com，所有的包名都以 com.haichufang 开头。包名中的每一个部分对应一个子目录。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象-接口]]></title>
    <url>%2F2018%2F07%2F09%2FInterface%2F</url>
    <content type="text"><![CDATA[接口用interface来声明，他不是类，而是抽象方法的集合。接口则包含类要实现的方法。一个类通过继承接口的方式实现接口的方法。 接口特性： 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。接口的声明1234[可见度] interface 接口名称 [extends 其他的类名] &#123; // 声明变量 // 抽象方法&#125; 例如：1234567/* 文件名 : NameOfInterface.java */import java.lang.*; //引入包public interface NameOfInterface&#123; //任何类型 final, static 字段 //抽象方法&#125; 注意： 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。 接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。 接口中的方法都是公有的。 实例：12345/* 文件名 : Animal.java */interface Animal &#123; public void eat(); public void travel();&#125; 接口的实现当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。 实例：12345/* 文件名 : Animal.java */interface Animal &#123; public void eat(); public void travel();&#125; 123456789101112131415161718192021/* 文件名 : MammalInt.java */public class MammalInt implements Animal&#123; public void eat()&#123; System.out.println("Mammal eats"); &#125; public void travel()&#123; System.out.println("Mammal travels"); &#125; public int noOfLegs()&#123; return 0; &#125; public static void main(String args[])&#123; MammalInt m = new MammalInt(); m.eat(); m.travel(); &#125;&#125; 运行结果如下： Mammal eats Mammal travels 重写接口中声明的方法时，需要注意以下规则： 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。 在实现接口的时候，也要注意一些规则： 一个类只能继承一个类，但是能实现多个接口; 一个接口能继承另一个接口，这和类之间的继承比较相似。 接口的继承接口的继承使用extends关键字12345// 文件名: Sports.javapublic interface Sports&#123; public void setHomeTeam(String name); public void setVisitingTeam(String name);&#125; 12345678// 文件名: Hockey.javapublic interface Hockey extends Sports&#123; public void homeGoalScored(); public void visitingGoalScored(); public void endOfPeriod(int period); public void overtimePeriod(int ot);&#125; 上述代码中：Hockey接口自己声明了四个方法，从Sports接口继承了两个方法，这样，实现Hockey接口的类需要实现六个方法。 接口的多继承接口允许多继承，但是extends关键字只是用一次。 public interface Hockey extends Sports, Event {} 标记接口没有任何方法的接口被成为标记接口。 作用： 建立一个公共的父接口： 正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。 向一个类添加数据类型： 这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象-封装]]></title>
    <url>%2F2018%2F07%2F07%2Fencapsulation%2F</url>
    <content type="text"><![CDATA[在面向对象程式设计方法中，封装是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。 封装的优点： 良好的封装能够减少耦合； 类内部的结构可以自由修改； 可以对成员变量进行更精确的控制； 隐藏信息，实现细节。 实现Java封装的步骤 修改属性的可见性来限制对属性的访问（一般限制为private），例如： 1234public class Person &#123; private String name; private int age;&#125; 这段代码中，将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如： 1234567891011121314151617181920public class Person&#123; private String name; private int age;​ public int getAge()&#123; return age; &#125;​ public String getName()&#123; return name; &#125; public void setAge(int age)&#123; this.age = age; &#125; public void setName(String name)&#123; this.name = name; &#125;&#125; 采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。 实例：12345678910111213141516171819202122232425262728293031/* 文件名: EncapTest.java */public class EncapTest&#123; private String name; private String idNum; private int age; public int getAge()&#123; return age; &#125; public String getName()&#123; return name; &#125; public String getIdNum()&#123; return idNum; &#125; public void setAge( int newAge)&#123; age = newAge; &#125; public void setName(String newName)&#123; name = newName; &#125; public void setIdNum( String newId)&#123; idNum = newId; &#125;&#125; public方法是外部类访问该类成员变量的入口。这些方法被称为getter和setter方法。任何要访问类中私有成员变量的类都要通过这些getter和setter方法。如下：1234567891011/* F文件名 : RunEncap.java */public class RunEncap&#123; public static void main(String args[])&#123; EncapTest encap = new EncapTest(); encap.setName("James"); encap.setAge(20); encap.setIdNum("12343ms"); System.out.print("Name : " + encap.getName()+ " Age : "+ encap.getAge()); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象-抽象类]]></title>
    <url>%2F2018%2F07%2F05%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。 父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。 在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类(extends)，而一个类却可以实现多个接口(implements)。 抽象类在Java语言中使用abstract class来定义抽象类，如下实例：1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 文件名 : Employee.java */public abstract class Employee&#123; private String name; private String address; private int number; public Employee(String name, String address, int number) &#123; System.out.println("Constructing an Employee"); this.name = name; this.address = address; this.number = number; &#125; public double computePay() &#123; System.out.println("Inside Employee computePay"); return 0.0; &#125; public void mailCheck() &#123; System.out.println("Mailing a check to " + this.name + " " + this.address); &#125; public String toString() &#123; return name + " " + address + " " + number; &#125; public String getName() &#123; return name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String newAddress) &#123; address = newAddress; &#125; public int getNumber() &#123; return number; &#125;&#125; Employee类作为抽象类，有3个成员变量，7个成员方法和1个构造方法，这和之前的类没有什么区别。但是，抽象类不允许实例化。以下代码运行时会抛出错误：123456789101112/* 文件名 : AbstractDemo.java */public class AbstractDemo&#123; public static void main(String [] args) &#123; /* 以下是不允许的，会引发错误 */ Employee e = new Employee("George W.", "Houston, TX", 43); System.out.println("\n Call mailCheck using Employee reference--"); e.mailCheck(); &#125;&#125; 继承抽象类尽管我们不能实例化抽象类Employee，但是我们可以通过一般的方法继承这个抽象类，然后进行实例化，实例化的对象将会从抽象类Employee继承7个成员方法，且通过该方法可以设置或者获取3个成员变量。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* 文件名 : Salary.java */public class Salary extends Employee&#123; private double salary; //Annual salary public Salary(String name, String address, int number, double salary) &#123; super(name, address, number); setSalary(salary); &#125; public void mailCheck() &#123; System.out.println("Within mailCheck of Salary class "); System.out.println("Mailing check to " + getName() + " with salary " + salary); &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double newSalary) &#123; if(newSalary &gt;= 0.0) &#123; salary = newSalary; &#125; &#125; public double computePay() &#123; System.out.println("Computing salary pay for " + getName()); return salary/52; &#125;&#125;``` ```java/* 文件名 : AbstractDemo.java */public class AbstractDemo&#123; public static void main(String [] args) &#123; Salary s = new Salary("Mohd Mohtashim", "Ambehta, UP", 3, 3600.00); Employee e = new Salary("John Adams", "Boston, MA", 2, 2400.00); System.out.println("Call mailCheck using Salary reference --"); s.mailCheck(); System.out.println("\n Call mailCheck using Employee reference--"); e.mailCheck(); &#125;&#125; 抽象方法Abstract关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体，所以也就没有“{}”。12345678910public abstract class Employee&#123; private String name; private String address; private int number; public abstract double computePay(); //其余代码&#125; 注意： 如果一个类包含抽象方法，那么该类必须是抽象类。 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。 继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。123456789101112/* 文件名 : Salary.java */public class Salary extends Employee&#123; private double salary; // Annual salary public double computePay() &#123; // 子类重写抽象方法 System.out.println("Computing salary pay for " + getName()); return salary/52; &#125; //其余代码&#125; 总结 抽象类不能被实例化，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 构造方法，类方法（用static修饰的方法）不能声明为抽象方法。 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象-多态]]></title>
    <url>%2F2018%2F07%2F04%2F%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态是指同一个行为具有多个不同表现形式或形态的能力。就是同一个接口，使用不同的实例而执行不同操作。 多态性是对象多种表现形式的体现。 多态的优点： 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性 多态存在的三个必要条件： 继承 重写 父类引用指向子类对象 如：Parent p = new Child(); 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。 多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Test &#123; public static void main(String[] args) &#123; show(new Cat()); // 以 Cat 对象调用 show 方法 show(new Dog()); // 以 Dog 对象调用 show 方法 Animal a = new Cat(); // 向上转型 a.eat(); // 调用的是 Cat 的 eat Cat c = (Cat)a; // 向下转型 c.work(); // 调用的是 Cat 的 work &#125; public static void show(Animal a) &#123; a.eat(); // 类型判断 if (a instanceof Cat) &#123; // 猫做的事情 Cat c = (Cat)a; c.work(); &#125; else if (a instanceof Dog) &#123; // 狗做的事情 Dog c = (Dog)a; c.work(); &#125; &#125; &#125; abstract class Animal &#123; //抽象处一个动物的类，具有吃这种方法 abstract void eat(); &#125; class Cat extends Animal &#123; public void eat() &#123; //猫子类重写动物类的吃的方法 System.out.println("吃鱼"); &#125; public void work() &#123; //猫子类扩展动物类方法 System.out.println("抓老鼠"); &#125; &#125; class Dog extends Animal &#123; public void eat() &#123; //狗子类重写动物类的吃的方法 System.out.println("吃骨头"); &#125; public void work() &#123; //狗子类扩展动物类方法 System.out.println("看家"); &#125; &#125; 执行以上程序，输出结果为： 吃鱼 抓老鼠 吃骨头 看家 吃鱼 抓老鼠 虚方法首先先来看一个例子12345678910111213141516171819202122232425262728293031/* 文件名 : Employee.java */public class Employee &#123; private String name; private String address; private int number; public Employee(String name, String address, int number) &#123; System.out.println("Employee 构造函数"); this.name = name; this.address = address; this.number = number; &#125; public void mailCheck() &#123; System.out.println("邮寄支票给： " + this.name + " " + this.address); &#125; public String toString() &#123; return name + " " + address + " " + number; &#125; public String getName() &#123; return name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String newAddress) &#123; address = newAddress; &#125; public int getNumber() &#123; return number; &#125;&#125; 下面的类 继承Employee类1234567891011121314151617181920212223242526/* 文件名 : Salary.java */public class Salary extends Employee&#123; private double salary; // 全年工资 public Salary(String name, String address, int number, double salary) &#123; super(name, address, number); setSalary(salary); &#125; public void mailCheck() &#123; System.out.println("Salary 类的 mailCheck 方法 "); System.out.println("邮寄支票给：" + getName() + " ，工资为：" + salary); &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double newSalary) &#123; if(newSalary &gt;= 0.0) &#123; salary = newSalary; &#125; &#125; public double computePay() &#123; System.out.println("计算工资，付给：" + getName()); return salary/52; &#125;&#125; 下面的类负责输出1234567891011/* 文件名 : VirtualDemo.java */public class VirtualDemo &#123; public static void main(String [] args) &#123; Salary s = new Salary("员工 A", "北京", 3, 3600.00); Employee e = new Salary("员工 B", "上海", 2, 2400.00); System.out.println("使用 Salary 的引用调用 mailCheck -- "); s.mailCheck(); System.out.println("\n使用 Employee 的引用调用 mailCheck--"); e.mailCheck(); &#125;&#125; 输出结果是: Employee 构造函数 Employee 构造函数 使用 Salary 的引用调用 mailCheck – Salary 类的 mailCheck 方法 邮寄支票给：员工 A ，工资为：3600.0 使用 Employee 的引用调用 mailCheck– Salary 类的 mailCheck 方法 邮寄支票给：员工 B ，工资为：2400.0 例子解析： 实例中，实例化了两个 Salary 对象：一个使用 Salary 引用 s，另一个使用 Employee 引用 e。 当调用 s.mailCheck() 时，编译器在编译时会在 Salary 类中找到 mailCheck()，执行过程 JVM 就调用 Salary 类的 mailCheck()。 因为 e 是 Employee 的引用，所以调用 e 的 mailCheck() 方法时，编译器会去 Employee 类查找 mailCheck() 方法 。 在编译的时候，编译器使用 Employee 类中的 mailCheck() 方法验证该语句， 但是在运行的时候，Java虚拟机(JVM)调用的是 Salary 类中的 mailCheck() 方法。 以上整个过程被称为虚拟方法调用，该方法被称为虚拟方法。 Java中所有的方法都能以这种方式表现，因此，重写的方法能在运行时调用，不管编译的时候源代码中引用变量是什么数据类型。 多态的实现方式 重写 接口 抽象类和抽象方法]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象-重写(Override)和重载(Overload)]]></title>
    <url>%2F2018%2F07%2F03%2F%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[重写(Override)重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。 12345678910111213141516171819202122class Animal&#123; public void move()&#123; System.out.println("动物可以移动"); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; System.out.println("狗可以跑和走"); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move();// 执行 Animal 类的方法 b.move();//执行 Dog 类的方法 &#125;&#125; 编译结果： 动物可以移动 狗可以跑和走 12345678910111213141516171819202122232425class Animal&#123; public void move()&#123; System.out.println("动物可以移动"); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; System.out.println("狗可以跑和走"); &#125; public void bark()&#123; System.out.println("狗可以吠叫"); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move();// 执行 Animal 类的方法 b.move();//执行 Dog 类的方法 b.bark(); &#125;&#125; 以上代买，b.bark()处抛出编译错误。注意Animal b = new Dog();和Dog b = new Dog(); 重写规则： 参数列表必须完全与被重写方法的相同； 返回类型必须完全与被重写方法的返回类型相同； 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 当需要在子类中调用父类的被重写方法时，要使用super关键字。123456789101112131415161718192021class Animal&#123; public void move()&#123; System.out.println("动物可以移动"); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; super.move(); // 应用super类的方法 System.out.println("狗可以跑和走"); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal b = new Dog(); // Dog 对象 b.move(); //执行 Dog类的方法 &#125;&#125; 以上实例编译运行结果如下： 动物可以移动 狗可以跑和走 重载(Overload)重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 最常用的地方就是构造器的重载。 重载规则: 被重载的方法必须改变参数列表(参数个数或类型不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。1234567891011121314151617181920212223242526272829public class Overloading &#123; public int test()&#123; System.out.println("test1"); return 1; &#125; public void test(int a)&#123; System.out.println("test2"); &#125; //以下两个参数类型顺序不同 public String test(int a,String s)&#123; System.out.println("test3"); return "returntest3"; &#125; public String test(String s,int a)&#123; System.out.println("test4"); return "returntest4"; &#125; public static void main(String[] args)&#123; Overloading o = new Overloading(); System.out.println(o.test()); o.test(1); System.out.println(o.test(1,"test3")); System.out.println(o.test("test4",1)); &#125;&#125; 重写与重载之间的区别 总结方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。 方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。 方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。 方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象-继承]]></title>
    <url>%2F2018%2F07%2F02%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[关键字extend：只能继承一个类。12public class Animal &#123; &#125;public class Penguin extends Animal&#123; &#125; implements: 变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。123public interface A &#123; public void eat(); public void sleep(); &#125;public interface B &#123; public void show(); &#125; public class C implements A,B &#123; &#125; super：访问父类成员，用来引用当前对象的父类。 this：指向自己的引用。12345678910111213141516class Animal &#123; void eat() &#123; System.out.println("animal : eat"); &#125; &#125; class Dog extends Animal &#123; void eat() &#123; System.out.println("dog : eat"); &#125; void eatTest() &#123; this.eat(); // this 调用自己的方法 super.eat(); // super 调用父类方法 &#125; &#125; public class Test &#123; public static void main(String[] args) &#123; Animal a = new Animal(); a.eat(); Dog d = new Dog(); d.eatTest(); &#125; &#125; final：声明类不能继承，即最终类；修饰方法不被子类重写12final class 类名&#123; //类体 &#125;修饰符（public/private/default/protected） final 返回值类型 方法名&#123; //方法体 &#125; 构造器构造器不能被子类继承。1.父类构造器有参数：子类构造器中必须用super传入参数；2.父类构造器没有参数，系统会自动调用，无需使用super。1234567891011121314151617181920212223242526272829class SuperClass &#123; private int n; SuperClass()&#123; System.out.println("SuperClass()"); &#125; SuperClass(int n) &#123; System.out.println("SuperClass(int n)"+ n); this.n = n; &#125;&#125;class SubClass extends SuperClass&#123; private int n; SubClass()&#123; super(300); System.out.println("SubClass"); &#125; public SubClass(int n)&#123; System.out.println("SubClass(int n):"+n); this.n = n; &#125;&#125;public class Structure&#123; public static void main (String args[])&#123; SubClass sc = new SubClass(); SubClass sc2 = new SubClass(200); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue_assembly]]></title>
    <url>%2F2018%2F06%2F21%2Fvue-assembly%2F</url>
    <content type="text"></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新奇好玩的CSS]]></title>
    <url>%2F2018%2F06%2F13%2FCss_new%2F</url>
    <content type="text"><![CDATA[最近在大漠的博客中看到好很多有意思的css效果，今天稍微整理一下。只做基本效果展示。 内凹角效果大体思路，伪类元素:before定位到父元素顶点处，利用box-shadow属性填充元素除:before外的其他区域，在 :before处形成内凹角。 上诉效果基本上已经实现了内凹角的效果 ，为了使用方便，还可以使用css自定义属性，控制内凹角的半径和位置，形成一个简单的组件。 在深入一点，可以加入js控制内凹角的半径，利用js改变自定义变量的值。 文字渐变这部分效果主要是使用background-clip:text、color:transparent和linear-gradient来完成。 字体变体这个效果，我一直以为只有靠图片来实现，再次感叹css的强大。利用font-variation-settings来实现，效果如下，感兴趣的童鞋，可以进行深入的学习：点击这里 写在最后再次感谢大漠，让我能见到这么多有趣的css。]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ES6箭头函数]]></title>
    <url>%2F2018%2F06%2F07%2F%E5%85%B3%E4%BA%8EES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[ES6发布到现在马上就要三年了，作为一个比较守旧的前端，一直也没有个系统的了解（主要是在小公司上班，工作中用不到啊，懒癌晚期的我，又没有足够的动力去系统的学习）。 最近公司项目（外包做的）bug频繁出现，有了用Vue重构的想法。至于为什么不用React，大概是觉得相比较而言，Vue更简单一些吧。在使用Vue脚手架的时候，接触到箭头函数，也是时候应该了解一下了。 好了，废话不多说了，下面说一下关于箭头函数的学习。 基本语法首先，先看一下箭头函数的基本语法： 1let func = value =&gt; value; 相当于： 123let func = function (value) &#123; return value; &#125;; 如果需要给函数传入多个参数： 1let func = (value, num) =&gt; value * num; 如果函数的代码块需要多条语句： 123let func = (value, num) =&gt; &#123; return value * num&#125;; 如果需要直接返回一个对象： 1let func = (value, num) =&gt; (&#123;total: value * num&#125;); 与变量解构结合： 12345678let func = (&#123;value, num&#125;) =&gt; (&#123;total: value * num&#125;)// 使用var result = func(&#123; value: 10, num: 10&#125;)console.log(result); // &#123;total: 100&#125; 比较没有this箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。 这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this。 模拟一个实际开发中的例子： 我们的需求是点击一个按钮，改变该按钮的背景色。 为了方便开发，我们抽离一个 Button 组件，当需要使用的时候，直接： 12// 传入元素 id 值即可绑定该元素点击时改变背景色的事件new Button(&quot;button&quot;) HTML 代码如下： 1&lt;button id=&quot;button&quot;&gt;点击变色&lt;/button&gt; JavaScript 代码如下： 1234567891011121314function Button(id) &#123; this.element = document.querySelector(&quot;#&quot; + id); this.bindEvent();&#125;Button.prototype.bindEvent = function() &#123; this.element.addEventListener(&quot;click&quot;, this.setBgColor, false);&#125;;Button.prototype.setBgColor = function() &#123; this.element.style.backgroundColor = &apos;#1abc9c&apos;&#125;;var button = new Button(&quot;button&quot;); 看着好像没有问题，结果却是报错 Uncaught TypeError: Cannot read property ‘style’ of undefined 这是因为当使用 addEventListener() 为一个元素注册事件的时候，事件函数里的 this 值是该元素的引用。 所以如果我们在 setBgColor 中 console.log(this)，this 指向的是按钮元素，那 this.element 就是 undefined，报错自然就理所当然了。 也许你会问，既然 this 都指向了按钮元素，那我们直接修改 setBgColor 函数为： 123Button.prototype.setBgColor = function() &#123; this.style.backgroundColor = &apos;#1abc9c&apos;&#125;; 不就可以解决这个问题了？ 确实可以这样做，但是在实际的开发中，我们可能会在 setBgColor 中还调用其他的函数，比如写成这种： 1234Button.prototype.setBgColor = function() &#123; this.setElementColor(); this.setOtherElementColor();&#125;; 所以我们还是希望 setBgColor 中的 this 是指向实例对象的，这样就可以调用其他的函数。 利用 ES5，我们一般会这样做： 123Button.prototype.bindEvent = function() &#123; this.element.addEventListener(&quot;click&quot;, this.setBgColor.bind(this), false);&#125;; 为避免 addEventListener 的影响，使用 bind 强制绑定 setBgColor() 的 this 为实例对象 使用 ES6，我们可以更好的解决这个问题： 123Button.prototype.bindEvent = function() &#123; this.element.addEventListener(&quot;click&quot;, event =&gt; this.setBgColor(event), false);&#125;; 由于箭头函数没有 this，所以会向外层查找 this 的值，即 bindEvent 中的 this，此时 this 指向实例对象，所以可以正确的调用 this.setBgColor 方法， 而 this.setBgColor 中的 this 也会正确指向实例对象。 在这里再额外提一点，就是注意 bindEvent 和 setBgColor 在这里使用的是普通函数的形式，而非箭头函数，如果我们改成箭头函数，会导致函数里的 this 指向 window 对象 (非严格模式下)。 最后，因为箭头函数没有 this，所以也不能用 call()、apply()、bind() 这些方法改变 this 的指向，可以看一个例子： 123var value = 1;var result = (() =&gt; this.value).bind(&#123;value: 2&#125;)();console.log(result); // 1 没有 arguments箭头函数没有自己的 arguments对象，这不一定是件坏事，因为箭头函数可以访问外围函数的 arguments 对象： 123456function constant() &#123; return () =&gt; arguments[0]&#125;var result = constant(1);console.log(result()); // 1 那如果我们就是要访问箭头函数的参数呢？ 你可以通过命名参数或者 rest 参数的形式访问参数: 1let nums = (...nums) =&gt; nums; 不能通过 new 关键字调用JavaScript 函数有两个内部方法：[[Call]] 和 [[Construct]]。 当通过 new 调用函数时，执行 [[Construct]] 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。 当直接调用的时候，执行 [[Call]] 方法，直接执行函数体。 箭头函数并没有 [[Construct]] 方法，不能被用作构造函数，如果通过 new 的方式调用，会报错。 12var Foo = () =&gt; &#123;&#125;;var foo = new Foo(); // TypeError: Foo is not a constructor 没有 new.target因为不能使用 new 调用，所以也没有 new.target 值。 关于 new.target，可以参考es6.ruanyifeng.com/#docs/class… 没有原型由于不能使用 new 调用箭头函数，所以也没有构建原型的需求，于是箭头函数也不存在 prototype 这个属性。 12var Foo = () =&gt; &#123;&#125;;console.log(Foo.prototype); // undefined 没有 super连原型都没有，自然也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的，不过跟 this、arguments、new.target 一样，这些值由外围最近一层非箭头函数决定。 总结最后，关于箭头函数，引用 MDN 的介绍就是： An arrow function expression has a shorter syntax than a function expression and does not have its own this, arguments, super, or new.target. These function expressions are best suited for non-method functions, and they cannot be used as constructors. 翻译过来就是： 箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数(non-method functions)，并且它们不能用作构造函数。 那么什么是 non-method functions 呢？ 我们先来看看 method 的定义： A method is a function which is a property of an object. 对象属性中的函数就被称之为 method，那么 non-mehtod 就是指不被用作对象属性中的函数了，可是为什么说箭头函数更适合 non-method 呢？ 让我们来看一个例子就明白了： 1234567891011var obj = &#123; i: 10, b: () =&gt; console.log(this.i, this), c: function() &#123; console.log( this.i, this) &#125;&#125;obj.b();// undefined Windowobj.c();// 10, Object &#123;...&#125; 自执行函数自执行函数的形式为： 123(function()&#123; console.log(1)&#125;)() 或者 123(function()&#123; console.log(1)&#125;()) 利用箭头简化自执行函数的写法： 123(() =&gt; &#123; console.log(1)&#125;)() 但是注意：使用以下这种写法却会报错： 123(() =&gt; &#123; console.log(1)&#125;()) ES6系列感谢冴羽的文章，作为ES6初学者，站在巨人的肩膀上学习，相对来说，还是简单不少的。更多ES6内容…]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css画QQ企鹅]]></title>
    <url>%2F2017%2F02%2F28%2FCss-QQ%2F</url>
    <content type="text"><![CDATA[写在前面随着Css高速发展，很多精致的效果已经可以不用依赖js、图片就可以实现。比如，接下来要绘制的QQ企鹅。 效果见： http://www.haoyuekai.com/others/CSS/QQ.html 开始绘制小企鹅分析小企鹅结构分析小企鹅身体结构。大致把企鹅分为头、身体、手、脚。 123456&lt;div id="qq"&gt; &lt;div id="head" class='head'&gt;&lt;/div&gt; &lt;div id="body" class="body"&gt;&lt;/div&gt; &lt;div id="hand" class="handWrapper"&gt;&lt;/div&gt; &lt;div id="foot" class='footWrapper'&gt;&lt;/div&gt;&lt;/div&gt; 绘制整体样式 12345678910111213/*qq*/#qq &#123; width: 420px; height: 400px; margin: 0 auto; margin-top: 100px; position: relative; display:block; -webkit-animation-name: startAni; -webkit-animation-duration: 1s; -moz-animation-name: startAni; -moz-animation-duration: 1s;&#125; 绘制小企鹅接下来，按照划分的结构，分别绘制 头部首先，绘制小企鹅的头部，还是先分析头部结构，划分为：眼睛（左右眼、眼球）、嘴巴（上下嘴唇、嘴角）。 123456789101112131415161718192021222324252627282930&lt;div id="head" class="head"&gt; &lt;div class='left eye'&gt; &lt;div class="eyelipLeftTop blink"&gt;&lt;/div&gt; &lt;div class="eyelipLeftBottom blink"&gt;&lt;/div&gt; &lt;div class="innerLeftEye blink"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class='right eye'&gt; &lt;div class="eyelipRightTop blink"&gt;&lt;/div&gt; &lt;div class="eyelipRightBottom blink"&gt;&lt;/div&gt; &lt;div class="innerRightEye blink"&gt; &lt;div class="fix"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class='mouthTopContainer'&gt; &lt;div class='mouthTop'&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="mouthBottomContainer"&gt; &lt;div class="mouthBottom"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="lipsContainer"&gt; &lt;div class="lips"&gt; &lt;div class="lipShadow left" id="lsl"&gt; &lt;/div&gt; &lt;div class="lipShadow right" id="lsr"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/head&gt; 开始绘制小企鹅头部 1234567891011121314.head&#123; position: absolute; top:18px; left: 96px; width: 234px; height: 185px; border: 1px solid #000; border-top-left-radius: 117px 117px; border-top-right-radius: 117px 117px; border-bottom-left-radius: 117px 68px; border-bottom-right-radius: 117px 68px; z-index:10; background-color: #000;&#125; *眼睛123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130.eye&#123; width: 44px; height: 66px; border:1px solid #000; border-radius: 50% 50%; position: absolute; background: #fff;&#125;.left.eye&#123; left:62px; top:50px; &#125;.right.eye&#123; left:123px; top:50px;&#125;.innerLeftEye&#123; position: absolute; top: 20px; left: 20px; width: 18px; height: 24px; border-radius: 50%; border: 1px solid #000; background: #000;&#125;.innerLeftEye:after&#123; content: ""; position: absolute; width: 6px; height: 8px; background: white; z-index: 11; top: 6px; left: 9px; border-radius: 50%;&#125;.innerLeftEye:before&#123; content: ""; position: absolute; width: 3px; height: 4px; background: white; z-index: 11; top: 14px; left: 4px; border-radius: 50%;&#125;.innerLeftEye.blink&#123; -webkit-animation-name: innerEyeBlink; -webkit-animation-duration: .2s; -webkit-animation-iteration-count: infinite; -webkit-transform-origin: 9px 12px; -moz-animation-name: innerEyeBlink; -moz-animation-duration: .2s; -moz-animation-iteration-count: infinite; -moz-transform-origin: 9px 12px;&#125;/*右眼同左眼*/.innerRightEye&#123; position: absolute; top: 20px; right: 20px; width: 18px; height: 24px; border-radius: 50%; border: 1px solid #000; background: #000;&#125;.innerRightEye:after&#123; content: ""; position: absolute; width: 6px; height: 8px; background: white; z-index: 11; top: 6px; right: 9px; border-radius: 50%;&#125;.innerRightEye:before&#123; content: ""; position: absolute; width: 3px; height: 4px; background: white; z-index: 11; top: 14px; right: 4px; border-radius: 50%;&#125;.innerRightEye.blink&#123; -webkit-animation-name: innerEyeBlink; -webkit-animation-duration: .2s; -webkit-animation-iteration-count: infinite; -webkit-transform-origin: 9px 12px; -moz-animation-name: innerEyeBlink; -moz-animation-duration: .2s; -moz-animation-iteration-count: infinite; -moz-transform-origin: 9px 12px;&#125;.eyelipLeftTop.blink, .eyelipRightTop.blink,.eyelipLeftBottom.blink, .eyelipRightBottom.blink&#123; display: block; height: 0px; position: absolute; width: 46px; background: black; border: 1px black solid; z-index: 100; -webkit-animation-name: eyelipAni1; -webkit-animation-duration: 4s; -webkit-animation-iteration-count: infinite; -moz-animation-name: eyelipAni1; -moz-animation-duration: 4s; -moz-animation-iteration-count: infinite;&#125;.eyelipLeftTop, .eyelipRightTop&#123; top: -2px; left: -2px; display: none;&#125;.eyelipLeftBottom, .eyelipRightBottom&#123; bottom:-2px; left:-2px; display: none;&#125; *嘴巴1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283.mouthTopContainer &#123; position: absolute; width: 158px; height: 29px; z-index: 1; top: 120px; left: 39px; overflow: hidden;&#125;.mouthTop&#123; width: 158px; height: 34px; position: absolute; z-index: 1; border:1px solid #FFA600; background: #FFA600; top: 0; left: 0; border-top-left-radius: 45% 34px; border-top-right-radius: 45% 34px; /*background-color: #FFA600; */&#125;.mouthBottomContainer &#123; position: absolute; width: 158px; height: 15px; z-index: 1; top: 146px; left: 39px; overflow: hidden;&#125;.mouthBottom&#123; width: 158px; height: 24px; position: absolute; z-index: 1; border:1px solid #FFA600; background: #FFA600; border-top:none; top: -4px; left: 0; border-bottom-left-radius: 45% 24px; border-bottom-right-radius: 45% 24px; background-color: #FFA600; &#125;.lips&#123; border: 1px solid #FFA600; background: #FFA600; width: 116px; height: 24px; position: absolute; top: 146px; left: 60px; border-top: none; border-bottom-left-radius: 50% 100%; border-bottom-right-radius: 50% 100%;&#125;.lipShadow &#123; width: 0px; height: 0px; position: absolute; z-index: 2; border-top: 20px solid transparent; border-bottom: 20px solid transparent; border-right: 8px solid black; -webkit-transform-origin: top right; -webkit-transform: rotate(-60deg); -moz-transform-origin: top right; -moz-transform: rotate(-60deg); -o-transform-origin: top right; -o-transform: rotate(-60deg); transform-origin: top right; transform: rotate(-60deg); left: -12px; top: 4px;&#125;.lipShadow.right&#123; left:114px; -webkit-transform: rotate(60deg) rotateY(180deg); -moz-transform: rotate(60deg) rotateY(180deg); -o-transform: rotate(60deg) rotateY(180deg); transform: rotate(60deg) rotateY(180deg);&#125; 身体分析小企鹅身体结构，划分为：围巾、肚子 1234567891011121314151617181920&lt;div id="body" class="body"&gt; &lt;div class="innerWrapper"&gt; &lt;div class="inner"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="outterWrapper"&gt; &lt;div class = 'outter'&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="scarf"&gt; &lt;div class="scarfShadow"&gt; &lt;/div&gt; &lt;div class="scarfShadowRight"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="scarfEnd"&gt; &lt;div class="scarfEndShadow"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 开始绘制小企鹅身体 12345678.body&#123; width: 326px; height: 300px; /*border: 1px solid black;*/ top: 135px; left: 48px; position: absolute;&#125; *围巾 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071.scarf &#123; border: 4px solid #000; position: absolute; background: #FB0009; z-index: 5; width: 258px; height: 110px; top: -2px; left: 34px; border-top-left-radius: 30px 34px; border-top-right-radius: 38px 34px; border-bottom-left-radius: 50% 76px; border-bottom-right-radius: 50% 76px; border-top: none; &#125;.scarfShadow &#123; position: absolute; border-top: 6px solid #000; width: 60px; height: 70px; top: 0px; left: 6px; border-top-left-radius: 90px 120px; border-top-right-radius: 30px 30px; -webkit-transform: rotate(-79deg); -moz-transform: rotate(-79deg); -o-transform: rotate(-79deg); transform: rotate(-79deg);&#125;.scarfShadowRight &#123; position: absolute; border-right: 6px solid black; width: 100px; height: 70px; top: 8px; left: 143px; border-bottom-right-radius: 70px 70px; z-index: 6;&#125;.scarfEnd&#123; position: absolute; width: 52px; height: 64px; z-index: 4; top: 90px; border: 3px solid black; left: 74px; border-bottom-left-radius: 50% 43%; border-bottom-right-radius: 15px; border-top-left-radius: 20% 57%; background: #FB0009;&#125;.scarfEndShadow&#123; position: absolute; border-top: 6px solid black; width: 20px; height: 20px; top: 6px; left: 12px; border-top-left-radius: 30px 30px; -webkit-transform-origin: top right; -moz-transform-origin: top right; -o-transform-origin: top right; transform-origin: top right; z-index: 10; -webkit-transform: skewX(4deg) scaleY(1.5) rotate(-60deg); -moz-transform: skewX(4deg) scaleY(1.5) rotate(-60deg); -o-transform: skewX(4deg) scaleY(1.5) rotate(-60deg); transform: skewX(4deg) scaleY(1.5) rotate(-60deg);&#125; *肚子 12345678910111213141516171819202122232425262728293031323334353637.innerWrapper&#123; position: absolute; overflow: hidden; width: 280px; height: 200px; left: 30px; top: 76px;&#125;.inner &#123; border: 1px solid #000; width: 218px; position: absolute; height: 210px; border-radius: 50%; left: 25px; top: -71px; z-index: 4; background: #fff;&#125;.outterWrapper&#123; width: 262px; left: 32px; height: 250px; position: absolute; top: 54px; overflow: hidden;&#125;.outter&#123; border: 1px solid #000; width: 260px; height: 250px; border-radius: 125px; position: absolute; top: -84px; z-index: 3; background: #000;&#125; 小手小企鹅手的结构比较简单 123456789101112131415161718&lt;div id="hand" class="handWrapper"&gt; &lt;div class="leftHandTopContainer"&gt; &lt;div class="leftHandTop"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="leftHandBottomContainer"&gt; &lt;div class="leftHandBottom"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="rightHandTopContainer"&gt; &lt;div class="rightHandTop"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="rightHandBottomContainer"&gt; &lt;div class="rightHandBottom"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 开始绘制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119.handWrapper&#123; position: absolute; top: 219px; left: 7px;&#125;.leftHandTopContainer&#123; width: 118px; height: 26px; position: absolute; z-index: 1; top: 55px; left: 50px; -webkit-transform-origin: bottom left; -webkit-transform: rotate(-70deg); -moz-transform-origin: bottom left; -moz-transform: rotate(-70deg); -o-transform-origin: bottom left; -o-transform: rotate(-70deg); transform-origin: bottom left; transform: rotate(-70deg); overflow: hidden;&#125;.leftHandTop&#123; width: 128px; height: 54px; border: 1px solid #050346; position: absolute; border-top-left-radius: 44% 38px; border-top-right-radius: 56% 33px; background: #000;&#125;.leftHandBottomContainer &#123; width: 115px; height: 30px; position: absolute; z-index: 1; top: 78px; left: 50px; -webkit-transform-origin: top left; -webkit-transform: rotate(-70deg); -moz-transform-origin: top left; -moz-transform: rotate(-70deg); -o-transform-origin: top left; -o-transform: rotate(-70deg); transform-origin: top left; transform: rotate(-70deg); overflow: hidden;&#125;.leftHandBottom&#123; width: 128px; height: 44px; border: 1px solid #050346; background: #000; border-top: none; position: absolute; border-bottom-left-radius: 48% 20px; border-bottom-right-radius: 52% 23px; top: -26px;&#125;.rightHandTopContainer&#123; width: 118px; height: 34px; position: absolute; z-index: 3; top: 47px; left: 240px; -webkit-transform-origin: bottom right; -webkit-transform: rotate(65deg); -moz-transform-origin: bottom right; -moz-transform: rotate(65deg); -o-transform-origin: bottom right; -o-transform: rotate(65deg); transform-origin: bottom right; transform: rotate(65deg); overflow: hidden;&#125;.rightHandTop&#123; width: 148px; height: 54px; border: 1px solid #050346; position: absolute; border-top-right-radius: 41% 54px; border-top-left-radius: 59% 48px; background: black; left: -30px; -webkit-transform: rotateY(-180deg); -moz-transform: rotateY(-180deg); -o-transform: rotateY(-180deg); transform: rotateY(-180deg);&#125;.rightHandBottomContainer&#123; width: 110px; height: 58px; position: absolute; z-index: 1; top: 81px; left: 248px; -webkit-transform-origin: top right; -webkit-transform: rotate(90deg); -moz-transform-origin: top right; -moz-transform: rotate(90deg); -o-transform-origin: top right; -o-transform: rotate(90deg); transform-origin: top right; transform: rotate(90deg); overflow: hidden;&#125;.rightHandBottom&#123; width: 68px; height: 28px; border: 1px solid #000; background: black; border-top: none; position: absolute; top: 1px; left: 38px; border-bottom-right-radius: 100% 40px; z-index: 999;&#125; 脚丫小企鹅脚丫的结构分为： 脚掌、脚趾 123456789101112131415161718192021&lt;div id="foot" class='footWrapper'&gt; &lt;div class="leftFootTopWrapper"&gt; &lt;div class="leftFootTop"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="leftFootBottomWrapper"&gt; &lt;div class="leftFootBottom"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class='toe left'&gt;&lt;/div&gt; &lt;div class="rightFootTopWrapper"&gt; &lt;div class="rightFootTop"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="rightFootBottomWrapper"&gt; &lt;div class="rightFootBottom"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class='toe right'&gt;&lt;/div&gt;&lt;/div&gt; 开始绘制小脚丫 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112.footWrapper&#123; position: absolute; top: 292px; left: 80px;&#125;.leftFootTopWrapper &#123; position: absolute; width: 130px; top: 16px; left: -1px; height: 37px; overflow: hidden; z-index: 2;&#125;.leftFootTop&#123; position: absolute; width: 120px; height: 60px; border: 4px solid black; background: #FF9C00; border-top-left-radius: 80% 70%; top: -10px; left: 3px;&#125;.toe &#123; position: absolute; border-top: 4px solid black; width: 25px; height: 20px; top: 50px; left: 2px; border-top-right-radius: 30px 30px; border-top-left-radius: 10px 10px; -webkit-transform-origin: top left; -moz-transform-origin: top left; -o-transform-origin: top left; transform-origin: top left; z-index: 10; -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -o-transform: rotate(-45deg); transform: rotate(-45deg);&#125;.toe.right&#123; -webkit-transform: rotate(45deg) rotateY(180deg); -moz-transform: rotate(45deg) rotateY(180deg); -o-transform: rotate(45deg) rotateY(180deg); transform: rotate(45deg) rotateY(180deg); left: 264px;&#125;.leftFootBottomWrapper &#123; position: absolute; width: 130px; top: 52px; left: -1px; height: 38px; overflow: hidden; z-index: 2;&#125;.leftFootBottom&#123; position: absolute; width: 120px; height: 60px; border: 4px solid #000; background: #FF9C00; border-top-left-radius: 50% 44%; border-top-right-radius: 50% 44%; border-bottom-left-radius: 50% 56%; border-bottom-right-radius: 50% 56%; top: -30px; left: 3px;&#125;.rightFootTopWrapper &#123; position: absolute; width: 134px; top: 22px; left: 134px; height: 36px; overflow: hidden; z-index: 2;&#125;.rightFootTop&#123; position: absolute; width: 120px; height: 60px; border: 4px solid black; background: #FF9C00; border-top-right-radius: 32% 65%; top: 0px; left: 4px;&#125;.rightFootBottomWrapper &#123; position: absolute; width: 134px; top: 52px; left: 134px; height: 38px; overflow: hidden;&#125;.rightFootBottom&#123; position: absolute; width: 120px; height: 60px; border: 4px solid #000; background: #FF9C00; border-top-left-radius: 50% 56%; border-top-right-radius: 50% 56%; border-bottom-left-radius: 50% 44%; border-bottom-right-radius: 50% 44%; top: -30px; left: 3px;&#125; 至此，小企鹅已经基本完成了 添加动画效果接下来，我们为小企鹅添加一些必要的动画，让小企鹅更加活灵活现 眼球自定义动画123456789101112131415161718192021222324252627/*眼球动画*/@-webkit-keyframes innerEyeBlink&#123; from&#123; -webkit-transform: rotate(0deg); &#125; 50%&#123; -webkit-transform: rotate(-5deg) &#125; 100% &#123; -webkit-transform: rotate(0deg) &#125;&#125;@-moz-keyframes innerEyeBlink&#123; from&#123; -moz-transform: rotate(0deg); &#125; 50%&#123; -moz-transform: rotate(-5deg) &#125; 100% &#123; -moz-transform: rotate(0deg) &#125;&#125; 眨眼自定义动画 12345678910111213141516171819202122232425262728293031323334/*眨眼睛*/@-webkit-keyframes eyelipAni1&#123; from &#123; height: 0px; &#125; 4% &#123; height: 34px; &#125; 8%&#123; height: 0px; &#125; to&#123; height: 0px; &#125;&#125;@-moz-keyframes eyelipAni1&#123; from &#123; height: 0px; &#125; 4% &#123; height: 34px; &#125; 8%&#123; height: 0px; &#125; to&#123; height: 0px; &#125;&#125; 入场动画自定义动画 1234567891011121314151617181920212223242526272829@-webkit-keyframes startAni&#123; from&#123; left: 210px; -webkit-transform: rotate(360deg) scale(.0001); &#125; 70%&#123; -webkit-transform: rotate(0deg) scale(1.5); &#125; to&#123; -webkit-transform: rotate(0deg) scale(1); &#125;&#125;@-moz-keyframes startAni&#123; from&#123; left: 210px; -moz-transform: rotate(360deg) scale(.0001); &#125; 70%&#123; -moz-transform: rotate(0deg) scale(1.5); &#125; to&#123; -moz-transform: rotate(0deg) scale(1); &#125;&#125; 动画效果添加完毕，当然，如果读者朋友有兴趣，还可以拓展一些其他的有趣的动作给我们可爱的小企鹅。 添加Css背景接下来，为我们的小企鹅添加一个好看的背景，因为是纯Css实现，这里不用背景图片，我们使用Css渐变，来绘制一个网格背景 123456789101112131415161718html &#123; background: -webkit-radial-gradient(50vmin 50vmin, #feb4ff, #a3a3ec); background: radial-gradient(50vmin 50vmin, #feb4ff, #a3a3ec); background-position: -20vw center; background-repeat: no-repeat; background-color: #a3a3ec; height: 100%;&#125;html body &#123; width: 100%; height: 100%; margin: 0; padding-top: 100px; box-sizing: border-box; background-image: -webkit-repeating-linear-gradient(330deg, rgba(255, 255, 255, 0.6), rgba(255, 255, 255, 0.6) 1px, transparent 1px, transparent 30px, rgba(255, 255, 255, 0.3) 30px, rgba(255, 255, 255, 0.3) 31px, transparent 31px, transparent 60px), -webkit-repeating-linear-gradient(30deg, rgba(255, 255, 255, 0.6), rgba(255, 255, 255, 0.6) 1px, transparent 1px, transparent 30px, rgba(255, 255, 255, 0.3) 30px, rgba(255, 255, 255, 0.3) 31px, transparent 31px, transparent 60px), -webkit-repeating-linear-gradient(top, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.3) 1px, transparent 1px, transparent 30px); background-image: repeating-linear-gradient(120deg, rgba(255, 255, 255, 0.6), rgba(255, 255, 255, 0.6) 1px, transparent 1px, transparent 30px, rgba(255, 255, 255, 0.3) 30px, rgba(255, 255, 255, 0.3) 31px, transparent 31px, transparent 60px), repeating-linear-gradient(60deg, rgba(255, 255, 255, 0.6), rgba(255, 255, 255, 0.6) 1px, transparent 1px, transparent 30px, rgba(255, 255, 255, 0.3) 30px, rgba(255, 255, 255, 0.3) 31px, transparent 31px, transparent 60px), repeating-linear-gradient(to bottom, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.3) 1px, transparent 1px, transparent 30px); background-size: 70px 120px;&#125; 总结到这里，一只卡哇伊的小企鹅，已经出现在我们的网页上了。Css来实现绘图，比较复杂，实际中不会用到，但是用来熟悉一下Css的一些属性，还是很不错的。最终的是可以培养一下自己的耐心。基于本人审美确实不怎么样，如果觉得有不满意的地方，可以自行修改，当然了，能分享给我之最好的。源码见https://github.com/haoyuekai/CSS-img/blob/master/QQ.html]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F02%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
